<!DOCTYPE html>
<html lang="en">
<head>
        <title>The Keras Blog - Francois Chollet</title>
        <meta charset="utf-8" />
        <link rel="stylesheet" href="http://blog.keras.io/theme/css/main.css" type="text/css" />
        <link rel="stylesheet" href="http://blog.keras.io/theme/css/pygment.css" type="text/css" />

        <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Source+Sans+Pro:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css">
        <link href="http://blog.keras.io/" type="application/atom+xml" rel="alternate" title="The Keras Blog ATOM Feed" />


        <!--[if IE]>
                <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

        <!--[if lte IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="http://blog.keras.io/css/ie.css"/>
                <script src="http://blog.keras.io/js/IE8.js" type="text/javascript"></script><![endif]-->

        <!--[if lt IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="http://blog.keras.io/css/ie6.css"/><![endif]-->

</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1>
                    <a href="http://blog.keras.io/index.html">The Keras Blog </a>
                </h1>
                <p id="side">
                    <a href="https://github.com/fchollet/keras">Keras</a> is a Deep Learning library for Python, that is simple, modular, and extensible.
                </p>
                <nav><ul>
                <li><a href="http://blog.keras.io/">Archives</a></li>
                    <li >
                        <a href="https://github.com/fchollet/keras">Github</a>
                    </li>
                    <li >
                        <a href="http://keras.io/">Documentation</a>
                    </li>
                    <li >
                        <a href="https://groups.google.com/forum/#!forum/keras-users">Google Group</a>
                    </li>
                </ul></nav>
        </header><!-- /#banner -->

     <section id="content" class="body">
        <aside id="featured"><article>
                <h1 class="entry-title"><a href="http://blog.keras.io/building-powerful-image-classification-models-using-very-little-data.html">Building powerful image classification models using very little data</a></h1>
<footer class="post-info">
        <abbr class="published" title="2016-06-05T00:00:00+02:00">
                Sun 05 June 2016
        </abbr>

        <address class="vcard author">
                By <a class="url fn" href="http://blog.keras.io/author/francois-chollet.html">Francois Chollet</a>
        </address>
<p>In <a href="http://blog.keras.io/category/tutorials.html">Tutorials</a>. </p>
</p></footer><!-- /.post-info --><!-- /.post-info -->
                <p>In this tutorial, we will present a few simple yet effective methods that you can use to build a powerful image classifier, using only very few training examples --just a few hundred or thousand pictures from each class you want to be able to recognize. </p>
<p>We will go over the following options:</p>
<ul>
<li>training a small network from scratch (as a baseline)</li>
<li>using the bottleneck features of a pre-trained network</li>
<li>fine-tuning the top layers of a pre-trained network</li>
</ul>
<p>This will lead us to cover the following Keras features:</p>
<ul>
<li><code>fit_generator</code> for training Keras a model using Python data generators</li>
<li><code>ImageDataGenerator</code> for real-time data augmentation</li>
<li>layer freezing and model fine-tuning</li>
<li>...and more.</li>
</ul>
<hr />
<h2>Our setup: only 2000 training examples (1000 per class)</h2>
<p>We will start from the following setup:</p>
<ul>
<li>a machine with Keras, SciPy, PIL installed. If you have a NVIDIA GPU that you can use (and cuDNN installed), that's great, but since we are working with few images that isn't strictly necessary. <em>Note that since this tutorial makes use of Keras features in introduced in version 1.0.4, <strong>you should update Keras before starting</strong>.</em></li>
<li>a training data directory and validation data directory containing one subdirectory per image class, filled with .png or .jpg images:</li>
</ul>
<div class="highlight"><pre>data/
    train/
        dogs/
            dog001.jpg
            dog002.jpg
            ...
        cats/
            cat001.jpg
            cat002.jpg
            ...
    validation/
        dogs/
            dog001.jpg
            dog002.jpg
            ...
        cats/
            cat001.jpg
            cat002.jpg
            ...
</pre></div>


<p>To acquire a few hundreds or thousands of training images belonging to the classes you are interested in, one possibility would be to use the <a href="https://www.flickr.com/services/api/">Flickr API</a> to download pictures matching a given tag, under a friendly license.</p>
<p>In our examples we will use two sets of pictures, which we got <a href="https://www.kaggle.com/c/dogs-vs-cats/data">from Kaggle</a>: 1000 cats and 1000 dogs (although the original dataset had 12,500 cats and 12,500 dogs, we just took the first 1000 images for each class). We also use 400 additional samples from each class as validation data, to evaluate our models.</p>
<p>That is very few examples to learn from, for a classification problem that is far from simple. So this is a challenging machine learning problem, but it is also a realistic one: in a lot of real-world use cases, even small-scale data collection can be extremely expensive or sometimes near-impossible (e.g. in medical imaging). Being able to make the most out of very little data is a key skill of a competent data scientist.</p>
<p><img alt="cats and dogs" src="/img/imgclf/cats_and_dogs.png" /></p>
<p>How difficult is this problem? When Kaggle started the cats vs. dogs competition (with 25,000 training images in total), a bit over two years ago, it came with the following statement:</p>
<p><em>"In an informal poll conducted many years ago, computer vision experts posited that a classifier with better than 60% accuracy would be difficult without a major advance in the state of the art. For reference, a 60% classifier improves the guessing probability of a 12-image HIP from 1/4096 to 1/459.
The current literature suggests machine classifiers can score above 80% accuracy on this task <a href="http://xenon.stanford.edu/~pgolle/papers/dogcat.pdf">[ref]</a>."</em></p>
<p>In the resulting competition, top entrants were able to score over 98% accuracy by using modern deep learning techniques. In our case, because we restrict ourselves to only 8% of the dataset, the problem is much harder.</p>
<h2>On the relevance of deep learning for small-data problems</h2>
<p>A message that I hear often is that "deep learning is only relevant when you have a huge amount of data". While not entirely incorrect, this is somewhat misleading. Certainly, deep learning requires the ability to learn features automatically from the data, which is generally only possible when lots of training data is available --especially for problems where the input samples are very high-dimensional, like images. However, convolutional neural networks --a pillar algorithm of deep learning-- are by design one of the best models available for most "perceptual" problems (such as image classification), even with very little data to learn from. Training a convnet from scratch on a small image dataset will still yield reasonable results, without the need for any custom feature engineering. Convnets are just plain good. They are the right tool for the job.</p>
<p>But what's more, deep learning models are by nature highly repurposable: you can take, say, an image classification or speech-to-text model trained on a large-scale dataset then reuse it on a significantly different problem with only minor changes, as we will see in this post. Specifically in the case of computer vision, many pre-trained models (usually trained on the ImageNet dataset) are now publicly available for download and can be used to bootstrap powerful vision models out of very little data.</p>
<hr />
<h2>Data pre-processing and data augmentation</h2>
<p>In order to make the most of our few training examples, we will "augment" them via a number of random transformations, so that our model would never see twice the exact same picture. This helps prevent overfitting and helps the model generalize better.</p>
<p>In Keras this can be done via the <code>keras.preprocessing.image.ImageDataGenerator</code> class. This class allows you to:</p>
<ul>
<li>configure random transformations and normalization operations to be done on your image data during training</li>
<li>instantiate generators of augmented image batches (and their labels) via <code>.flow(data, labels)</code> or <code>.flow_from_directory(directory)</code>. These generators can then be used with the Keras model methods that accept data generators as inputs, <code>fit_generator</code>, <code>evaluate_generator</code> and <code>predict_generator</code>.</li>
</ul>
<p>Let's look at an example right away:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">keras.preprocessing.image</span> <span class="kn">import</span> <span class="n">ImageDataGenerator</span>

<span class="n">datagen</span> <span class="o">=</span> <span class="n">ImageDataGenerator</span><span class="p">(</span>
        <span class="n">rotation_range</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
        <span class="n">width_shift_range</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
        <span class="n">height_shift_range</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
        <span class="n">rescale</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span>
        <span class="n">shear_range</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
        <span class="n">zoom_range</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
        <span class="n">horizontal_flip</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="n">fill_mode</span><span class="o">=</span><span class="s">&#39;nearest&#39;</span><span class="p">)</span>
</pre></div>


<p>These are just a few of the options available (for more, see <a href="http://keras.io/preprocessing/image/">the documentation</a>). Let's quickly go over what we just wrote:</p>
<ul>
<li><code>rotation_range</code> is a value in degrees (0-180), a range within which to randomly rotate pictures</li>
<li><code>width_shift</code> and <code>height_shift</code> are ranges (as a fraction of total width or height) within which to randomly translate pictures vertically or horizontally</li>
<li><code>rescale</code> is a value by which we will multiply the data before any other processing. Our original images consist in RGB coefficients in the 0-255, but such values would be too high for our models to process (given a typical learning rate), so we target values between 0 and 1 instead by scaling with a 1/255. factor.</li>
<li><code>shear_range</code> is for randomly applying <a href="https://en.wikipedia.org/wiki/Shear_mapping">shearing transformations</a></li>
<li><code>zoom_range</code> is for randomly zooming inside pictures</li>
<li><code>horizontal_flip</code> is for randomly flipping half of the images horizontally --relevant when there are no assumptions of horizontal assymetry (e.g. real-world pictures).</li>
<li><code>fill_mode</code> is the strategy used for filling in newly created pixels, which can appear after a rotation or a width/height shift.</li>
</ul>
<p>Now let's start generating some pictures using this tool and save them to a temporary directory, so we can get a feel for what our augmentation strategy is doing --we disable rescaling in this case to keep the images displayable:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">keras.preprocessing.image</span> <span class="kn">import</span> <span class="n">ImageDataGenerator</span><span class="p">,</span> <span class="n">array_to_img</span><span class="p">,</span> <span class="n">img_to_array</span><span class="p">,</span> <span class="n">load_img</span>

<span class="n">datagen</span> <span class="o">=</span> <span class="n">ImageDataGenerator</span><span class="p">(</span>
        <span class="n">rotation_range</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
        <span class="n">width_shift_range</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
        <span class="n">height_shift_range</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
        <span class="n">shear_range</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
        <span class="n">zoom_range</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
        <span class="n">horizontal_flip</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="n">fill_mode</span><span class="o">=</span><span class="s">&#39;nearest&#39;</span><span class="p">)</span>

<span class="n">img</span> <span class="o">=</span> <span class="n">load_img</span><span class="p">(</span><span class="s">&#39;data/train/cats/cat.0.jpg&#39;</span><span class="p">)</span>  <span class="c"># this is a PIL image</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">img_to_array</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>  <span class="c"># this is a Numpy array with shape (3, 150, 150)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c"># this is a Numpy array with shape (1, 3, 150, 150)</span>

<span class="c"># the .flow() command below generates batches of randomly transformed images</span>
<span class="c"># and saves the results to the `preview/` directory</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">datagen</span><span class="o">.</span><span class="n">flow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                          <span class="n">save_to_dir</span><span class="o">=</span><span class="s">&#39;preview&#39;</span><span class="p">,</span> <span class="n">save_prefix</span><span class="o">=</span><span class="s">&#39;cat&#39;</span><span class="p">,</span> <span class="n">save_format</span><span class="o">=</span><span class="s">&#39;jpeg&#39;</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
        <span class="k">break</span>  <span class="c"># otherwise the generator would loop indefinitely</span>
</pre></div>


<p>Here's what we get --this is what our data augmentation strategy looks like.</p>
<p><img alt="cat data augmentation" src="/img/imgclf/cat_data_augmentation.png" /></p>
<hr />
<h2>Training a small convnet from scratch: 80% accuracy in 40 lines of code</h2>
<p>The right tool for an image classification job is a convnet, so let's try to train one on our data, as an initial baseline. Since we only have few examples, our number one concern should be <strong>overfitting</strong>. Overfitting happens when a model exposed to too few examples learns patterns that do not generalize to new data, i.e. when the model starts using irrelevant features for making predictions. For instance, if you, as a human, only see three images of people who are lumberjacks, and three, images of people who are sailors, and among them only one lumberjack wears a cap, you might start thinking that wearing a cap is a sign of being a lumberjack as opposed to a sailor. You would then make a pretty lousy lumberjack/sailor classifier.</p>
<p>Data augmentation is one way to fight overfitting, but it isn't enough since our augmented samples are still highly correlated. Your main focus for fighting overfitting should be the entropic capacity of your model --how much information your model is allowed to store. A model that can store a lot of information has the potential to be more accurate by leveraging more features, but it is also more at risk to start storing irrelevant features. Meanwhile, a model that can only store a few features will have to focus on the most significant features found in the data, and these are more likely to be truly relevant and to generalize better.</p>
<p>There are different ways to modulate entropic capacity. The main one is the choice of the number of parameters in your model, i.e. the number of layers and the size of each layer. Another way is the use of weight regularization, such as L1 or L2 regularization, which consists in forcing model weights to taker smaller values.</p>
<p>In our case we will use a very small convnet with few layers and few filters per layer, alongside data augmentation and dropout. Dropout also helps reduce overfitting, by preventing a layer from seeing twice the exact same pattern, thus acting in a way analoguous to data augmentation (you could say that both dropout and data augmentation tend to disrupt random correlations occuring in your data).</p>
<p>The code snippet below is our first model, a simple stack of 3 convolution layers with a ReLU activation and followed by max-pooling layers. This is very similar to the architectures that Yann LeCun advocated in the 1990s for image classification (with the exception of ReLU).</p>
<p>The full code for this experiment can be found <a href="https://gist.github.com/fchollet/0830affa1f7f19fd47b06d4cf89ed44d">here</a>.</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">keras.models</span> <span class="kn">import</span> <span class="n">Sequential</span>
<span class="kn">from</span> <span class="nn">keras.layers</span> <span class="kn">import</span> <span class="n">Convolution2D</span><span class="p">,</span> <span class="n">MaxPooling2D</span>
<span class="kn">from</span> <span class="nn">keras.layers</span> <span class="kn">import</span> <span class="n">Activation</span><span class="p">,</span> <span class="n">Dropout</span><span class="p">,</span> <span class="n">Flatten</span><span class="p">,</span> <span class="n">Dense</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">Sequential</span><span class="p">()</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Convolution2D</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">input_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">150</span><span class="p">)))</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Activation</span><span class="p">(</span><span class="s">&#39;relu&#39;</span><span class="p">))</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">MaxPooling2D</span><span class="p">(</span><span class="n">pool_size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>

<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Convolution2D</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Activation</span><span class="p">(</span><span class="s">&#39;relu&#39;</span><span class="p">))</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">MaxPooling2D</span><span class="p">(</span><span class="n">pool_size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>

<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Convolution2D</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Activation</span><span class="p">(</span><span class="s">&#39;relu&#39;</span><span class="p">))</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">MaxPooling2D</span><span class="p">(</span><span class="n">pool_size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>

<span class="c"># the model so far outputs 3D feature maps (height, width, features)</span>
</pre></div>


<p>On top of it we stick two fully-connected layers. We end the model with a single unit and a sigmoid activation, which is perfect for a binary classification. To go with it we will also use the <code>binary_crossentropy</code> loss to train our model.</p>
<div class="highlight"><pre><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Flatten</span><span class="p">())</span>  <span class="c"># this converts our 3D feature maps to 1D feature vectors</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dense</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Activation</span><span class="p">(</span><span class="s">&#39;relu&#39;</span><span class="p">))</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Activation</span><span class="p">(</span><span class="s">&#39;sigmoid&#39;</span><span class="p">))</span>

<span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">loss</span><span class="o">=</span><span class="s">&#39;binary_crossentropy&#39;</span><span class="p">,</span>
              <span class="n">optimizer</span><span class="o">=</span><span class="s">&#39;rmsprop&#39;</span><span class="p">,</span>
              <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;accuracy&#39;</span><span class="p">])</span>
</pre></div>


<p>Let's prepare our data. We will use <code>.flow_from_directory()</code> to generate batches of image data (and their labels) directly from our jpgs in their respective folders.</p>
<div class="highlight"><pre><span class="c"># this is the augmentation configuration we will use for training</span>
<span class="n">train_datagen</span> <span class="o">=</span> <span class="n">ImageDataGenerator</span><span class="p">(</span>
        <span class="n">rescale</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span>
        <span class="n">shear_range</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
        <span class="n">zoom_range</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
        <span class="n">horizontal_flip</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c"># this is the augmentation configuration we will use for testing:</span>
<span class="c"># only rescaling</span>
<span class="n">test_datagen</span> <span class="o">=</span> <span class="n">ImageDataGenerator</span><span class="p">(</span><span class="n">rescale</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mi">255</span><span class="p">)</span>

<span class="c"># this is a generator that will read pictures found in</span>
<span class="c"># subfolers of &#39;data/train&#39;, and indefinitely generate</span>
<span class="c"># batches of augmented image data</span>
<span class="n">train_generator</span> <span class="o">=</span> <span class="n">train_datagen</span><span class="o">.</span><span class="n">flow_from_directory</span><span class="p">(</span>
        <span class="s">&#39;data/train&#39;</span><span class="p">,</span>  <span class="c"># this is the target directory</span>
        <span class="n">target_size</span><span class="o">=</span><span class="p">(</span><span class="mi">150</span><span class="p">,</span> <span class="mi">150</span><span class="p">),</span>  <span class="c"># all images will be resized to 150x150</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
        <span class="n">class_mode</span><span class="o">=</span><span class="s">&#39;binary&#39;</span><span class="p">)</span>  <span class="c"># since we use binary_crossentropy loss, we need binary labels</span>

<span class="c"># this is a similar generator, for validation data</span>
<span class="n">validation_generator</span> <span class="o">=</span> <span class="n">test_datagen</span><span class="o">.</span><span class="n">flow_from_directory</span><span class="p">(</span>
        <span class="s">&#39;data/validation&#39;</span><span class="p">,</span>
        <span class="n">target_size</span><span class="o">=</span><span class="p">(</span><span class="mi">150</span><span class="p">,</span> <span class="mi">150</span><span class="p">),</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
        <span class="n">class_mode</span><span class="o">=</span><span class="s">&#39;binary&#39;</span><span class="p">)</span>
</pre></div>


<p>We can now use these generators to train our model.
Each epoch takes 20-30s on GPU and 300-400s on CPU. So it's definitely viable to run this model on CPU if you aren't in a hurry.</p>
<div class="highlight"><pre><span class="n">model</span><span class="o">.</span><span class="n">fit_generator</span><span class="p">(</span>
        <span class="n">train_generator</span><span class="p">,</span>
        <span class="n">samples_per_epoch</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
        <span class="n">nb_epoch</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
        <span class="n">validation_data</span><span class="o">=</span><span class="n">validation_generator</span><span class="p">,</span>
        <span class="n">nb_val_samples</span><span class="o">=</span><span class="mi">800</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">save_weights</span><span class="p">(</span><span class="s">&#39;first_try.h5&#39;</span><span class="p">)</span>  <span class="c"># always save your weights after training or during training</span>
</pre></div>


<p>This approach gets us to a validation accuracy of 0.79-0.81 after 50 epochs (a number that was picked arbitrarily --because the model is small and uses aggressive dropout, it does not seem to be overfitting too much by that point). So at the time the Kaggle competition was launched, we would be already be "state of the art" --with 8% of the data, and no effort to optimize our architecture or hyperparameters. In fact, in the Kaggle competition, this model would have scored in the top 100 (out of 215 entrants). I guess that at least 115 entrants weren't using deep learning ;)</p>
<p>Note that the variance of the validation accuracy is fairly high, both because accuracy is a high-variance metric and because we only use 800 validation samples. A good validation strategy in such cases would be to do k-fold cross-validation, but this would require training k models for every evaluation round.</p>
<hr />
<h2>Using the bottleneck features of a pre-trained network: 90% accuracy in a minute</h2>
<p>A more refined approach would be to leverage a network pre-trained on a large dataset. Such a network would have already learned features that are useful for most computer vision problems, and leveraging such features would allow us to reach a better accuracy than any method that would only rely on the available data.</p>
<p>We will use the VGG16 architecture, pre-trained on the ImageNet dataset --a model previously featured on this blog. Because the ImageNet dataset contains several "cat" classes (persian cat, siamese cat...) and many "dog" classes among its total of 1000 classes, this model will already have learned features that are relevant to our classification problem. In fact, it is possible that merely recording the softmax predictions of the model over our data rather than the bottleneck features would be enough to solve our dogs vs. cats classification problem extremely well. However, the method we present here is more likely to generalize well to a broader range of problems, including problems featuring classes absent from ImageNet.</p>
<p>Here's what the VGG16 architecture looks like:</p>
<p><img src="/img/imgclf/vgg16_original.png" alt="vgg16" style="width: 400px;"/></p>
<p>Our strategy will be as follow: we will only instantiate the convolutional part of the model, everything up to the fully-connected layers. We will then run this model on our training and validation data once, recording the output (the "bottleneck features" from th VGG16 model: the last activation maps before the fully-connected layers) in two numpy arrays. Then we will train a small fully-connected model on top of the stored features.</p>
<p>The reason why we are storing the features offline rather than adding our fully-connected model directly on top of a frozen convolutional base and running the whole thing, is computational effiency. Running VGG16 is expensive, especially if you're working on CPU, and we want to only do it once. Note that this prevents us from using data augmentation.</p>
<p>You can find the full code for this experiment <a href="https://gist.github.com/fchollet/f35fbc80e066a49d65f1688a7e99f069">here</a>. You can get the weights file <a href="https://gist.github.com/baraldilorenzo/07d7802847aaad0a35d3">from Github</a>. We won't review how the model is built and loaded --this is covered in multiple Keras examples already. But let's take a look at how we record the bottleneck features using image data generators:</p>
<div class="highlight"><pre><span class="n">generator</span> <span class="o">=</span> <span class="n">datagen</span><span class="o">.</span><span class="n">flow_from_directory</span><span class="p">(</span>
        <span class="s">&#39;data/train&#39;</span><span class="p">,</span>
        <span class="n">target_size</span><span class="o">=</span><span class="p">(</span><span class="mi">150</span><span class="p">,</span> <span class="mi">150</span><span class="p">),</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
        <span class="n">class_mode</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>  <span class="c"># this means our generator will only yield batches of data, no labels</span>
        <span class="n">shuffle</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>  <span class="c"># our data will be in order, so all first 1000 images will be cats, then 1000 dogs</span>
<span class="c"># the predict_generator method returns the output of a model, given</span>
<span class="c"># a generator that yields batches of numpy data</span>
<span class="n">bottleneck_features_train</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict_generator</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)</span>
<span class="c"># save the output as a Numpy array</span>
<span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">&#39;bottleneck_features_train.npy&#39;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">),</span> <span class="n">bottleneck_features_train</span><span class="p">)</span>

<span class="n">generator</span> <span class="o">=</span> <span class="n">datagen</span><span class="o">.</span><span class="n">flow_from_directory</span><span class="p">(</span>
        <span class="s">&#39;data/validation&#39;</span><span class="p">,</span>
        <span class="n">target_size</span><span class="o">=</span><span class="p">(</span><span class="mi">150</span><span class="p">,</span> <span class="mi">150</span><span class="p">),</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
        <span class="n">class_mode</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
        <span class="n">shuffle</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">bottleneck_features_validation</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict_generator</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="mi">800</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">&#39;bottleneck_features_validation.npy&#39;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">),</span> <span class="n">bottleneck_features_validation</span><span class="p">)</span>
</pre></div>


<p>We can then load our saved data and train a small fully-connected model:</p>
<div class="highlight"><pre><span class="n">train_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">&#39;bottleneck_features_train.npy&#39;</span><span class="p">))</span>
<span class="c"># the features were saved in order, so recreating the labels is easy</span>
<span class="n">train_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>

<span class="n">validation_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">&#39;bottleneck_features_validation.npy&#39;</span><span class="p">))</span>
<span class="n">validation_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">400</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">400</span><span class="p">)</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">Sequential</span><span class="p">()</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Flatten</span><span class="p">(</span><span class="n">input_shape</span><span class="o">=</span><span class="n">train_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dense</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">&#39;relu&#39;</span><span class="p">))</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">&#39;sigmoid&#39;</span><span class="p">))</span>

<span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s">&#39;rmsprop&#39;</span><span class="p">,</span>
              <span class="n">loss</span><span class="o">=</span><span class="s">&#39;binary_crossentropy&#39;</span><span class="p">,</span>
              <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;accuracy&#39;</span><span class="p">])</span>

<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_data</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">,</span>
          <span class="n">nb_epoch</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
          <span class="n">validation_data</span><span class="o">=</span><span class="p">(</span><span class="n">validation_data</span><span class="p">,</span> <span class="n">validation_labels</span><span class="p">))</span>
<span class="n">model</span><span class="o">.</span><span class="n">save_weights</span><span class="p">(</span><span class="s">&#39;bottleneck_fc_model.h5&#39;</span><span class="p">)</span>
</pre></div>


<p>Thanks to its small size, this model trains very quickly even on CPU (1s per epoch):</p>
<div class="highlight"><pre>Train on 2000 samples, validate on 800 samples
Epoch 1/50
2000/2000 [==============================] - 1s - loss: 0.8932 - acc: 0.7345 - val_loss: 0.2664 - val_acc: 0.8862
Epoch 2/50
2000/2000 [==============================] - 1s - loss: 0.3556 - acc: 0.8460 - val_loss: 0.4704 - val_acc: 0.7725
...
Epoch 47/50
2000/2000 [==============================] - 1s - loss: 0.0063 - acc: 0.9990 - val_loss: 0.8230 - val_acc: 0.9125
Epoch 48/50
2000/2000 [==============================] - 1s - loss: 0.0144 - acc: 0.9960 - val_loss: 0.8204 - val_acc: 0.9075
Epoch 49/50
2000/2000 [==============================] - 1s - loss: 0.0102 - acc: 0.9960 - val_loss: 0.8334 - val_acc: 0.9038
Epoch 50/50
2000/2000 [==============================] - 1s - loss: 0.0040 - acc: 0.9985 - val_loss: 0.8556 - val_acc: 0.9075
</pre></div>


<p>We reach a validation accuracy of 0.90-0.91: not bad at all. This is definitely partly due to the fact that the base model was trained on a dataset that already featured dogs and cats (among hundreds of other classes).</p>
<hr />
<h2>Fine-tuning the top layers of a a pre-trained network</h2>
<p>To further improve our previous result, we can try to "fine-tune" the last convolutional block of the VGG16 model alongside the top-level classifier. Fine-tuning consist in starting from a trained network, then re-training it on a new dataset using very small weight updates. In our case, this can be done in 3 steps:</p>
<ul>
<li>instantiate the convolutional base of VGG16 and load its weights</li>
<li>add our previously defined fully-connected model on top, and load its weights</li>
<li>freeze the layers of the VGG16 model up to the last convolutional block</li>
</ul>
<p><img src="/img/imgclf/vgg16_modified.png" alt="vgg16: fine-tuning" style="width: 400px;"/></p>
<p>Note that:</p>
<ul>
<li>in order to perform fine-tuning, all layers should start with properly trained weights: for instance you should not slap a randomly initialized fully-connected network on top of a pre-trained convolutional base. This is because the large gradient updates triggered by the randomly initialized weights would wreck the learned weights in the convolutional base. In our case this is why we first train the top-level classifier, and only then start fine-tuning convolutional weights alongside it.</li>
<li>we choose to only fine-tune the last convolutional block rather than the entire network in order to prevent overfitting, since the entire network would have a very large entropic capacity and thus a strong tendency to overfit. The features learned by low-level convolutional blocks are more general, less abstract than those found higher-up, so it is sensible to keep the first few blocks fixed (more general features) and only fine-tune the last one (more specialized features).</li>
<li>fine-tuning should be done with a very slow learning rate, and typically with the SGD optimizer rather than an adaptative learning rate optimizer such as RMSProp. This is to make sure that the magnitude of the updates stays very small, so as not to wreck the previously learned features.</li>
</ul>
<p>You can find the full code for this experiment <a href="https://gist.github.com/fchollet/7eb39b44eb9e16e59632d25fb3119975">here</a>.</p>
<p>After instantiating the VGG base and loading its weights, we add our previously trained fully-connected classifier on top:</p>
<div class="highlight"><pre><span class="c"># build a classifier model to put on top of the convolutional model</span>
<span class="n">top_model</span> <span class="o">=</span> <span class="n">Sequential</span><span class="p">()</span>
<span class="n">top_model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Flatten</span><span class="p">(</span><span class="n">input_shape</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
<span class="n">top_model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dense</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">&#39;relu&#39;</span><span class="p">))</span>
<span class="n">top_model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span>
<span class="n">top_model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">&#39;sigmoid&#39;</span><span class="p">))</span>

<span class="c"># note that it is necessary to start with a fully-trained</span>
<span class="c"># classifier, including the top classifier,</span>
<span class="c"># in order to successfully do fine-tuning</span>
<span class="n">top_model</span><span class="o">.</span><span class="n">load_weights</span><span class="p">(</span><span class="n">top_model_weights_path</span><span class="p">)</span>

<span class="c"># add the model on top of the convolutional base</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">top_model</span><span class="p">)</span>
</pre></div>


<p>We then proceed to freeze all convolutional layers up to the last convolutional block:</p>
<div class="highlight"><pre><span class="c"># set the first 25 layers (up to the last conv block)</span>
<span class="c"># to non-trainable (weights will not be updated)</span>
<span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[:</span><span class="mi">25</span><span class="p">]:</span>
    <span class="n">layer</span><span class="o">.</span><span class="n">trainable</span> <span class="o">=</span> <span class="bp">False</span>

<span class="c"># compile the model with a SGD/momentum optimizer</span>
<span class="c"># and a very slow learning rate.</span>
<span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">loss</span><span class="o">=</span><span class="s">&#39;binary_crossentropy&#39;</span><span class="p">,</span>
              <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizers</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="n">lr</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">momentum</span><span class="o">=</span><span class="mf">0.9</span><span class="p">),</span>
              <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;accuracy&#39;</span><span class="p">])</span>
</pre></div>


<p>Finally, we start training the whole thing, with a very slow learning rate:</p>
<div class="highlight"><pre><span class="c"># prepare data augmentation configuration</span>
<span class="n">train_datagen</span> <span class="o">=</span> <span class="n">ImageDataGenerator</span><span class="p">(</span>
        <span class="n">rescale</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span>
        <span class="n">shear_range</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
        <span class="n">zoom_range</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
        <span class="n">horizontal_flip</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">test_datagen</span> <span class="o">=</span> <span class="n">ImageDataGenerator</span><span class="p">(</span><span class="n">rescale</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mi">255</span><span class="p">)</span>

<span class="n">train_generator</span> <span class="o">=</span> <span class="n">train_datagen</span><span class="o">.</span><span class="n">flow_from_directory</span><span class="p">(</span>
        <span class="n">train_data_dir</span><span class="p">,</span>
        <span class="n">target_size</span><span class="o">=</span><span class="p">(</span><span class="n">img_height</span><span class="p">,</span> <span class="n">img_width</span><span class="p">),</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
        <span class="n">class_mode</span><span class="o">=</span><span class="s">&#39;binary&#39;</span><span class="p">)</span>

<span class="n">validation_generator</span> <span class="o">=</span> <span class="n">test_datagen</span><span class="o">.</span><span class="n">flow_from_directory</span><span class="p">(</span>
        <span class="n">validation_data_dir</span><span class="p">,</span>
        <span class="n">target_size</span><span class="o">=</span><span class="p">(</span><span class="n">img_height</span><span class="p">,</span> <span class="n">img_width</span><span class="p">),</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
        <span class="n">class_mode</span><span class="o">=</span><span class="s">&#39;binary&#39;</span><span class="p">)</span>

<span class="c"># fine-tune the model</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit_generator</span><span class="p">(</span>
        <span class="n">train_generator</span><span class="p">,</span>
        <span class="n">samples_per_epoch</span><span class="o">=</span><span class="n">nb_train_samples</span><span class="p">,</span>
        <span class="n">nb_epoch</span><span class="o">=</span><span class="n">nb_epoch</span><span class="p">,</span>
        <span class="n">validation_data</span><span class="o">=</span><span class="n">validation_generator</span><span class="p">,</span>
        <span class="n">nb_val_samples</span><span class="o">=</span><span class="n">nb_validation_samples</span><span class="p">)</span>
</pre></div>


<p>This approach gets us to a validation accuracy of 0.94 after 50 epochs. Great success!</p>
<p>Here are a few more approaches you can try to get to above 0.95:</p>
<ul>
<li>more aggresive data augmentation</li>
<li>more aggressive dropout</li>
<li>use of L1 and L2 regularization (also known as "weight decay")</li>
<li>fine-tuning one more convolutional block (alongside greater regularization)</li>
</ul>
<hr />
<p>This post ends here! To recap, here is where you can find the code for our three experiments:</p>
<ul>
<li><a href="https://gist.github.com/fchollet/0830affa1f7f19fd47b06d4cf89ed44d">Convnet trained from scratch</a></li>
<li><a href="https://gist.github.com/fchollet/f35fbc80e066a49d65f1688a7e99f069">Bottleneck features</a></li>
<li><a href="https://gist.github.com/fchollet/7eb39b44eb9e16e59632d25fb3119975">Fine-tuning</a></li>
</ul>
<p>If you have any comment about this post or any suggestion about future topics to cover, you can reach out <a href="https://twitter.com/fchollet">on Twitter</a>.</p>
<hr />
        </article></aside><!-- /#featured -->
                <h1>Other articles</h1>
                <hr />
                    <ol id="posts-list" class="hfeed">
        <li><article class="hentry">
                <header>
                        <h1><a href="http://blog.keras.io/building-autoencoders-in-keras.html" rel="bookmark" title="Permalink to Building Autoencoders in Keras">Building Autoencoders in Keras</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2016-05-14T00:00:00+02:00">
                Sat 14 May 2016
        </abbr>

        <address class="vcard author">
                By <a class="url fn" href="http://blog.keras.io/author/francois-chollet.html">Francois Chollet</a>
        </address>
<p>In <a href="http://blog.keras.io/category/tutorials.html">Tutorials</a>. </p>
</p></footer><!-- /.post-info --><!-- /.post-info -->
                <p>In this tutorial, we will answer some common questions about autoencoders, and we will cover code examples of the following models:</p>
<ul>
<li>a simple autoencoder based on a fully-connected layer</li>
<li>a sparse autoencoder</li>
<li>a deep fully-connected autoencoder</li>
<li>a deep convolutional autoencoder</li>
<li>an image denoising model</li>
<li>a sequence-to-sequence autoencoder</li>
<li>a variational autoencoder ...</li></ul>
                <a class="readmore" href="http://blog.keras.io/building-autoencoders-in-keras.html">read more</a>
                </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header>
                        <h1><a href="http://blog.keras.io/keras-as-a-simplified-interface-to-tensorflow-tutorial.html" rel="bookmark" title="Permalink to Keras as a simplified interface to TensorFlow: tutorial">Keras as a simplified interface to TensorFlow: tutorial</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2016-04-24T00:00:00+02:00">
                Sun 24 April 2016
        </abbr>

        <address class="vcard author">
                By <a class="url fn" href="http://blog.keras.io/author/francois-chollet.html">Francois Chollet</a>
        </address>
<p>In <a href="http://blog.keras.io/category/tutorials.html">Tutorials</a>. </p>
</p></footer><!-- /.post-info --><!-- /.post-info -->
                <h1>A complete guide to using Keras as part of a TensorFlow workflow</h1>
<p>If TensorFlow is your primary framework, and you are looking for a simple &amp; high-level model definition interface to make your life easier, this tutorial is for you.</p>
<p>Keras layers and models are fully compatible with pure-TensorFlow tensors, and ...</p>
                <a class="readmore" href="http://blog.keras.io/keras-as-a-simplified-interface-to-tensorflow-tutorial.html">read more</a>
                </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header>
                        <h1><a href="http://blog.keras.io/introducing-keras-10.html" rel="bookmark" title="Permalink to Introducing Keras 1.0">Introducing Keras 1.0</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2016-04-11T00:00:00+02:00">
                Mon 11 April 2016
        </abbr>

        <address class="vcard author">
                By <a class="url fn" href="http://blog.keras.io/author/francois-chollet.html">Francois Chollet</a>
        </address>
<p>In <a href="http://blog.keras.io/category/news.html">News</a>. </p>
</p></footer><!-- /.post-info --><!-- /.post-info -->
                <p>Keras was initially released a year ago, late March 2015. It has made tremendous progress since, both on the development front, and as a community.</p>
<p>But continuous improvement isn't enough. A year of developing Keras, using Keras, and getting feedback from thousands of users has taught us a lot ...</p>
                <a class="readmore" href="http://blog.keras.io/introducing-keras-10.html">read more</a>
                </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header>
                        <h1><a href="http://blog.keras.io/how-convolutional-neural-networks-see-the-world.html" rel="bookmark" title="Permalink to How convolutional neural networks see the world">How convolutional neural networks see the world</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2016-01-30T00:00:00+01:00">
                Sat 30 January 2016
        </abbr>

        <address class="vcard author">
                By <a class="url fn" href="http://blog.keras.io/author/francois-chollet.html">Francois Chollet</a>
        </address>
<p>In <a href="http://blog.keras.io/category/demo.html">Demo</a>. </p>
</p></footer><!-- /.post-info --><!-- /.post-info -->
                <h2>An exploration of convnet filters with Keras</h2>
<p>In this post, we take a look at what deep convolutional neural networks (convnets) really learn, and how they understand the images we feed them. We will use Keras to visualize inputs that maximize the activation of the filters in different layers of ...</p>
                <a class="readmore" href="http://blog.keras.io/how-convolutional-neural-networks-see-the-world.html">read more</a>
                </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header>
                        <h1><a href="http://blog.keras.io/keras-now-running-on-tensorflow.html" rel="bookmark" title="Permalink to Keras, now running on TensorFlow">Keras, now running on TensorFlow</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2015-12-01T00:00:00+01:00">
                Tue 01 December 2015
        </abbr>

        <address class="vcard author">
                By <a class="url fn" href="http://blog.keras.io/author/francois-chollet.html">Francois Chollet</a>
        </address>
<p>In <a href="http://blog.keras.io/category/news.html">News</a>. </p>
</p></footer><!-- /.post-info --><!-- /.post-info -->
                <p>The purpose of Keras is to be a model-level framework, providing a set of "Lego blocks" for building Deep Learning models in a fast and straightforward way.
Among Deep Learning frameworks, Keras is resolutely high up on the ladder of abstraction.</p>
<p>As such, Keras does not handle itself low-level tensor ...</p>
                <a class="readmore" href="http://blog.keras.io/keras-now-running-on-tensorflow.html">read more</a>
                </div><!-- /.entry-content -->
        </article></li>
</ol><!-- /#posts-list -->
</section><!-- /#content -->

        <footer id="footer" class="body">
                <address id="about" class="vcard body">
                Powered by <a href="http://alexis.notmyidea.org/pelican/">pelican</a>, which takes great advantages of <a href="http://python.org">python</a>.
                </address><!-- /#about -->
        </footer><!-- /#footer -->

    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-61785484-1");
    pageTracker._trackPageview();
    } catch(err) {}</script>
</body>
</html>